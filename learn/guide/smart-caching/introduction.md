Фреймворк имеет встроенные механизмы кэширования результатов выполнения геттеров. Это позволяет снизить требование к вычислительным ресурсам и повысить отзывчивость web-страницы.

Совокупность значений свойств компонента, используемых в коде геттера, образует контекст выполнения гетера. Кеширование геттера основано на принципе, что если его контекст не изменился, то и результат выполнения геттера не изменится.

Механизм кэширования работает следующим образом:

1. на этапе создания компонента фреймворк анализирует от каких свойств компонента зависит геттер;

1. при первом выполнении геттера возвращенное значение запоминается в кэше;

1. при последующих вызовах геттера проверяется наличие изменений в контексте геттера. Если изменений не произошло, то геттер не выполняется, а значение берется из кэша. Если изменения произошли, расчет выполняется заново и новое значение опять запоминается в кэше.

```info_md
Каждый геттер имеет свой кэш, независимый от других геттеров.
```

Рассмотрим пример:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});
```

В примере на экран должно выводиться текущее время с точностью до миллисекунд. Для получения времени используются геттер **getterTime** и метод **methodTime**. Но на экран время выводится только при загрузке страницы и больше не обновляется. Это происходит потому, что компонент не меняет своего состояния (не изменяются значения свойств) и, следовательно, рендеринг компонента не осуществляется.

Измените значение в строке ввода. За счет механизма двойного биндинга, при вводе или удалении каждого символа осуществляется изменение свойства **change** компонента, что приводит к рендерингу компонента. При этом текущее время обновляется, но только для значений, получаемых из метода, а значение геттера не изменяется, т.к. в его коде нет обращения к свойству **change**.

```warning_md
Обратите внимание, если код геттера не содержит обращений к свойствам компонента, то у него отсутствует контекст, и он вычисляется один раз и превращается в константу.
```

Добавим в геттер **getterTime** обращение к свойству **change**:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                this.change;
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});
```

Измените значение в строке ввода. Теперь оба и геттер, и метод обновляют время на экране при каждом добавлении или удалении символа. Обратите внимание, что в коде геттера свойство **change** просто упоминается, никаких операций с ним не производится. То есть для сброса кэша геттера и его выполнения достаточно изменить значение используемого в нем свойства компонента.
