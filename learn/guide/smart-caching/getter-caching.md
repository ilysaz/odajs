Совокупность значений свойств компонента, используемых в коде геттера, образую контекст выполнения гетера. Кеширование геттера основано на принципе, что если его контекст не изменился, то и результат выполнения геттера не изменится.

Механизм кэширования работает следующим образом:

1. на этапе создания компонента фреймворк анализирует от каких свойств компонента зависит геттер;

1. при первом выполнении геттера возвращенное значение запоминается в кэше;

1. при последующих вызовах геттера проверяется наличие изменений в контексте геттера. Если изменений не произошло, то геттер не выполняется, а значение берется из кэша. Если изменения произошли, расчет выполняется заново и новое значение опять запоминается в кэше.

```info_md
Каждый геттер имеет свой кэш, независимый от других геттеров и от кэша методов.
```

Изменение значений свойств компонента в процессе выполнения геттера не приводит к очистке кэша этого геттера, так как геттер уже фактически выполняется от обновленного контекста.

---



```warning_md
С осторожностью изменяйте значения свойств компонента в методе, вызываемом при рендеринге web-страницы. Такое изменение очищает кэш методов и приводит к их выполнению при следующем рендеринге web-страницы.
```

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <div>Счетчик из геттера: {{getterCount}}</div>
        <div>Счетчик из метода: {{methodCount()}}</div>
    `,
    props: {
        count1: 0,
        count2: 0,
        getterCount: {
            get() {
                return ++this.count1;
            }
        }
    },
    methodCount() {
        return ++this.count2;
    }
});
```

В примере видно, что изменение свойства **count2** в методе **methodCount** приводит к очистке кэша методов и выполнению метода при каждом рендеринге страницы. В тоже время изменение свойства **count1** в геттере не приводит к очистке кэша геттера и повторному выполнению, поэтому счетчик **count1** инкрементируется только один раз при загрузке страницы.

```warning_md
С осторожностью используйте для изменения значения одного и того же свойства несколько геттеров. Это может привести к взаимному сбросу кэшей этих геттеров, и их непрерывному выполнению.
```

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <div>Счетчик из геттера 1: {{getterCount1}}</div>
        <div>Счетчик из геттера 2: {{getterCount2}}</div>
    `,
    props: {
        count: 0,
        getterCount1: {
            get() {
                return ++this.count;
            }
        }
    },
    get getterCount2() {
            return ++this.count;
    }
});
```

В примере изменение свойства **count** в геттере **getterCount1** сбрасывает кэш геттера **getterCount2**, что приводит к его выполнению. В этом геттере свойство **count** опять изменяется и сбрасывает кэш геттера **getterCount1**. Фактически такое использование свойства **count** отключает кэши обоих геттеров и приводит к их выполнению при каждом рендеринге страницы.

В коде геттера обязательно должно быть обращение к какому-либо свойству, которое сбрасывает кэш гетера, иначе геттер превращается в константу. Обращение к свойству не обязательно должно быть непосредственно в коде геттера, обращение может находиться в одном из вызываемых геттером методов.

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время из геттера: {{getterTime}}</div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                this.hiddenChange();
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    hiddenChange() {
        this.change;
    }
});
```

В примере геттер **getterTime** в своем коде не содержит обращение к счетчику **change**, но он вызывает метод **hiddenChange**, в котором такое обращение присутствует, поэтому при любом изменении текста в строке ввода текущее время на странице обновляется.

```warning_md
Чтобы свойство начало управлять сбросом кэша геттера, необходимо при выполнении гетера обратиться к нему хотя бы один раз.
```

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <button @tap="permission=!permission">Permit={{permission}}</button>
        <div>Время из геттера: {{getterTime}}</div>
    `,
    props: {
        count: 0,
        permission: false,
        getterTime: {
            get() {
                if(this.permission) this.count;
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    attached() {
        setInterval( ()=>{++this.count}, 1000);
    }
});
```

Сразу после загрузки страницы геттер **getterTime** выполняется один раз и время на экране больше не обновляется. При первом выполнении геттера обращение к свойству **count** было заблокировано условным оператором. Нажмите на кнопку **Permit**, чтобы заставить геттер выполниться второй раз из-за изменения значения свойства **permission**. При этом в условном операторе произойдет обращение к свойству **count**. Теперь при каждом изменении счетчика **count** кэш геттера сбрасывается и происходит выполнение геттера, что видно по изменению времени на странице. Если повторно нажать на кнопку **Permit**, то условный оператор опять заблокирует обращение к свойству **count**, однако отсчет времени не прекратиться, так как свойство **count** уже зарегистрировано для управления кэшем.

Изменение состояния одного независимого компонента не влияет на очистку кэша методов другого независимого компонента.

Например:

```html run_line_edit_h=46_
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Welcome to ODA.js</title>
        <script type="module" src="https://cdn.jsdelivr.net/gh/odajs/oda-framework/oda.js"></script>
    </head>
    <body>
        <my-count></my-count>
        <my-time></my-time>
        <script type="module">
            ODA({
                is: 'my-time,
                template: `
                    <div>Время из метода: {{methodTime()}}</div>
                `,
                methodTime() {
                    var d = new Date();
                    return d.toLocaleTimeString() + '.' + d.getMilliseconds();
                }
            });

            ODA({
                is: 'my-count',
                template: `
                    <button @tap="++count">Счетчик: {{count}}</button>
                `,
                count: 0
            });
        </script>
    </body>
</html>
```

В примере время, выводимое компонентом **my-component** при нажатии на кнопку **Счетчик**, не обновляется, потому что состояние компонента не изменяется. Изменение состояния компонента **my-count** на него не влияет, так оба компонента взаимно независимые.

Если объединить несколько компонентов в одном компоненте, то кэш методов у них становится общим. Следовательно, изменение состояния любого из объединенных компонентов влияет на выполнение методов во всех остальных компонентах.

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <my-change></my-change>
        <my-time></my-time>
    `
});

ODA({
    is: 'my-time',
    template: `
        <div>Время из метода: {{methodTime()}}</div>
    `,
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});

ODA({
    is: 'my-change',
    template: `
        <input ::value="change">
    `,
    change: "Измени меня"
});
```

В примере изменение текста в строке ввода в компоненте **my-change** изменяет состояние всего компонента **my-component**, поэтому сбрасывается кэш методов в компоненте **my-time**, и время на странице обновляется.

Кэш методов становится общим также в случае включения одного компонента в состав другого.

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <my-change></my-change>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});

ODA({
    is: 'my-change',
    template: `
        <input ::value="change">
    `,
    change: "Измени меня"
});
```

В примере изменение текста в строке ввода в подчиненном компоненте **my-change** изменяет состояние всего компонента **my-component**, поэтому время на странице обновляется.

Кэш методов становится общим также в случае наследования компонентов.

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    extends: 'my-change',
    template: `
        <div>Время из метода: {{methodTime()}}</div>
    `,
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});

ODA({
    is: 'my-change',
    template: `
        <input ::value="change">
    `,
    change: "Измени меня"
});
```

В примере изменение текста в строке ввода в родительском компоненте **my-change** изменяет состояние всего компонента **my-component**, поэтому время на странице обновляется.

```info_md
Кэш методов становится общим и сбрасывается одновременно для всех компонентов, объединенных в одном компоненте, независимо от метода объединения.
```
