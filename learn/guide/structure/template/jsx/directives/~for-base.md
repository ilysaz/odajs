Директива **~for** используется для создания последовательности однотипных HTML-элементов на основе заданного JSX-шаблона и указанного источника данных. В процессе работы директива последовательно извлекает элементы из источника данных, и на основе каждого такого элемента создает из шаблона очередной HTML-элемент.

В общем случае директива имеет следующий формат:

```info md_hideicon
**~for="item, index, items, key in dataSource"**
```

Параметр **dataSource** определяет источник данных для директивы. Источником данных могут быть массивы и объекты, а также любые JavaScript-выражения, значения которых фреймворк может преобразовать в массив или объект.

Параметры **item**, **index**, **items** и **key** являются переменными цикла и могут использоваться в шаблоне в JavaScript-выражениях. Эти параметры являются необязательными. Если какие-то переменные цикла не используются в шаблоне создаваемого HTML-элемента, то соответствующие параметры можно опустить при объявлении директивы.

Переменная цикла **item** содержит элемент данных, взятый из источника в текущем цикле.

Пример 1:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item in array">Элемент: {{item}}</div>
    `,
    props: {
        array: [
            'A', 'B', 'C'
        ]
    }
});
```

В приведенном примере из массива **array** последовательно извлекаются все элементы, и для каждого из них создается свой собственный HTML-элемент **div**. В этот элемент выводится значение текущего элемента массива, которое берется из переменной **item**.

Переменная цикла **index** содержит порядковый номер текущего элемента данных в источнике данных. Нумерация начинается с нуля. Если источник данных является массивом, то эта переменная фактически является индексом текущего элемента массива.

Пример 2:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index in array">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        array: [
            'A', 'B', 'C'
        ]
    }
});
```

Этот пример аналогичен предыдущему с учетом того, что помимо значения элемента массива также выводится его индекс, который берется из переменной цикла **index**.

Переменная цикла **items** является указателем на источник данных, из которого директива непосредственно извлекает данные. Если параметр **dataSource** является объектом или массивом, то **items** указывает на него. Если **dataSource** является JavaScript-выражением, то **items** указывает на внутренний источник данных, который сформировал фреймворк из результата выполнения этого выражения.

Пример 3:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items in array">Элемент[{{index}}]: {{item}} - array: {{items}}</div>
    `,
    props: {
        array: [
            'A', 'B', 'C'
        ]
    }
});
```

Этот пример аналогичен предыдущему с учетом того, что в каждом элементе **div** дополнительно выводится содержимое исходного массива, на который ссылается указатель **items**.

Переменная цикла **key** содержит имя текущего свойства объекта, если источник данных является объектом. Если источник данных является массивом, то эта переменная содержит порядковый номер элемента данных аналогично переменной **index**.

Пример 4:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items, key in object">{{index+1}}-е свойство {{key}}: {{item}} -- object: {{JSON.stringify(items)}}</div>
    `,
    props: {
        object: {
            prop1:'A', prop2:'B', prop3:'C'
        }
    }
});
```

В приведенном примере из объекта **object** последовательно извлекаются все свойства, и для каждого из них создается свой собственный HTML-элемент **div**. Переменная **index** используется для вывода порядкового номера свойства. Переменная **key** используется для вывода имени свойства. Переменная **item** используется для вывода значения свойства. Переменная **items** используется для вывода содержимого всего объекта.


```info_md
Кроме структуры цикла **for...in**, можно использовать структуру **for...of**.
```

Пример 5:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items, key of object">{{index+1}}-е свойство {{key}}: {{item}} -- object: {{JSON.stringify(items)}}</div>
    `,
    props: {
        object: {
            prop1:'A', prop2:'B', prop3:'C'
        }
    }
});
```

Результат выполнения этого примера будет точно таким же, как и у предыдущего.

```info_md
Если при объявлении директивы **~for** опущены какие-то параметры, то фреймворк автоматически создаст для них переменные с именами **item**, **index**, **items**, **key** соответственно.
```

Пример 6:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="object">{{index+1}}-е свойство {{key}}: {{item}} -- object: {{JSON.stringify(items)}}</div>
    `,
    props: {
        object: {
            prop1:'A', prop2:'B', prop3:'C'
        }
    }
});
```

Результат выполнения этого примера будет точно таким же, как и у предыдущего. За исключением того, что в директиве **~for** указан только источник данных, а переменные цикла **item**, **index**, **items** и **key** создаются фреймворком автоматически.

```warning_md
Если компонент имеет свойства с такими же именами как у переменных цикла в директиве **~for**, то в качестве значений переменных цикла будут использоваться значения свойств компонента.
```

Пример 7:

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items, key in object">{{index}}-е свойство {{key}}: {{item}} -- object: {{JSON.stringify(items)}}</div>
    `,
    props: {
        object: {
            prop1:'A', prop2:'B', prop3:'C'
        },
        item: 'ошибка',
        index: 'N',
        items: 'неправильная ссылка',
        key: 'error'
    }
});
```

В этом примере значения переменных цикла **item**, **index**, **items** и **key** будут одинаковыми во всех созданных **div** элементах, т.к. они перекрываются значениями свойств самого компонента с теми же самыми именами.

```info_md
Область действия переменных цикла ограничена HTML-элементом, в котором объявлена директива **~for**. На уровне компонента переменные цикла недоступны.
```

Пример 8:

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items, key in object">{{key}}: {{this.item}}</div>
    `,
    props: {
        object: {
            prop1:'A', prop2:'B', prop3:'C'
        }
    }
});
```

В этом примере мы пытаемся обратиться к переменной цикла **item**, используя указатель на компонент **this**. Но поскольку эта переменная не является свойством компонента, на страницу выводится значение **undefind**.

Если необходимо использовать переменную цикла за пределами HTML-элемента, в котором она объявлена, то ее необходимо передать методу в качестве параметра.

Пример 9:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items, key in object">{{key}}: {{getItem(items,key)}}</div>
    `,
    props: {
        object: {
            prop1:'A', prop2:'B', prop3:'C'
        }
    },
    getItem(obj, prop) {
        return obj[prop];
    }
});
```

В этом примере текущее значение для директивы **~for** формируется методом **getItem**. В качестве параметров этому методу передаются источник данных из переменной **items** и имя текущего свойства из переменной **key**.

Директива **~for** обрабатывает все элементы из источника данных, даже если эти элементы неопределенны.

Пример 10:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        array: [
            'A', , 'C'
        ]
    }
});
```

В этом примере в объявлении массива **array** пропущен элемент с индексом **1**. Однако фреймворк все равно создает для него HTML-элемент **div**, используя значение **undefind**.

Чтобы исключить создание HTML-элементов для отсутствующих элементов исходных данных, директиву **~for** необходимо использовать совместно с директивой **~if**, параметром которой служит текущий элемент данных.

Пример 11:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array" ~if="item">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        array: [
            'A', , 'C'
        ]
    }
});
```

Этот пример аналогичен предыдущему, за исключением того, что неопределенный элемент с индексом **1** из массива **array** теперь отфильтровывается директивой **~if="item"**.

С помощью директивы **~for** можно вывести последовательность целых чисел, начиная с 1, если значение, указанное в источнике данных, можно привести к целому типу. Последнее число в генерируемой последовательности определяется значением источника данных.

Пример 12:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="Math.floor(count)">Элемент[{{index}}]: {{item}} – источник данных: [{{items}}]</div>
    `,
    props: {
        count: 7.1
    }
});
```

В данном примере в качестве источника данных используется JS-выражение, преобразующее вещественное число к целому типу. В данном примере это выражении равно 7, поэтому директива создает семь элементов **div**. Переменная цикла **items** используется для демонстрации содержимого реального источника данных, с которым оперирует директива. В данном примере это массив с последовательностью целых чисел от 1 до 7.

Если источником данных является символьная строка, то директива **~for** обрабатывает ее как массив отдельных символов.

Пример 13:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="count">Элемент[{{index}}]: {{item}} – источник данных: [{{items}}]</div>
    `,
    props: {
        count: "Привет!"
    }
});
```

В данном примере в качестве источника данных используется символьная строка **"Привет!"**. Директива раскладывает ее на отдельные символы. Переменная цикла **items** используется для демонстрации содержимого реального источника данных, с которым оперирует директива.















```info_md
HTML-элементы с директивами **~for** можно вкладывать друг в друга, создавая многомерные конструкции.
```

Пример 12:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="element, number, sourse, prop in object">
            <div ~for="element">{{prop}}[{{index}}]: {{item}}</div>
        </div>
    `,
    props: {
        object: {
            array_1: ['A', 'B', 'C'],
            array_2: ['D', 'E', 'F']
        }
    }
});
```

В этом примере директива **~for** во внешнем элементе **div** поочередно выбирает свойства объекта **object**, которые являются одномерными массивами. Затем эти массивы через переменную цикла **element** передаются директиве **~for** во вложенном элементе **div**. Вторая директива разбирает массивы на отдельные значения и выводит их на web-страницу.

Обратите внимание, что переменная цикла **element** из внешней директивы используется в качестве источника данных во второй директиве. Во внешней директиве пришлось явно указать все переменные цикла, хотя в шаблоне используются только первая и последняя переменные **element** и **prop**. Переменные цикла во внутренней директиве не заданы, в шаблоне используются переменные **item** и **index**, создаваемые фреймворком по умолчанию.

```warning_md
Во внешних и вложенных директивах **~for** имена переменных цикла должны обязательно различаться. Иначе переменные внешних директив будут перекрывать переменные внутренних директив.
```

Пример 13:

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array_1">
            <div ~for="item, index, items in array_2">Элемент[{{index}}]: {{item}} -- Источник: {{items}}</div>
        </div>
    `,
    props: {
        array_1: ['A', 'B', 'C'],
        array_2: ['D', 'E', 'F']
    }
});
```

В этом примере во внешней директиве **~for** переменные цикла не указаны явно, поэтому их имена заданы по умолчанию **item**, **index** и **items**. Во вложенной директиве **~for** переменные цикла указаны явно и имеют такие же имена, т.е. имена переменных перекрываются. В результате, хотя для вложенной директивы в качестве источника данных указан массив **array_2**, на страницу выводятся только данные из массива **array_1**, указанного во внешней директиве.

На самом деле, в случае совпадения имен переменных во внешней и вложенной директивах **~for**, фреймворк неявным образом модифицирует имена переменных во вложенной директиве, добавляя в конце имени символ **1**. Эти модифицированные имена можно использовать в шаблоне элемента.

Пример 14:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array_1">
            <div ~for="item, index, items in array_2">Элемент[{{index1}}]: {{item1}} -- Источник: {{items1}}</div>
        </div>
    `,
    props: {
        array_1: ['A', 'B', 'C'],
        array_2: ['D', 'E', 'F']
    }
});
```

В этом примере, как и в предыдущем, во внешней и вложенной директивах имена переменных цикла совпадают. Но в шаблоне вложенного элемента **div** используются переменные, к именам которых добавлен символ **1**. Эти переменные не объявлены во вложенной директиве, более того в директиве используются совсем другие имена, однако именно эти необъявленные переменные фреймворк использует в качестве переменных цикла. В результате на web-страницу выводятся данные из массива **array_2**, который указан источником данных во вложенной директиве.

```info_md
Для минимизации объема кода и ускорения процесса программирования при создании иерархии вложенных директив **~for** можно опустить все параметры, указав только источник данных. В этом случае для внешней директивы фреймворк автоматически создаст переменные цикла с именами **item**, **index**, **items** и **key** соответственно. Для вложенных директив будут созданы переменные с аналогичными именами, к которым добавлены цифровые индексы, соответствующие глубине вложенности.
```

Пример 15:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array">
            <div ~for="item">
                <div ~for="item1">Элемент[{{index}},{{index1}},{{index2}}]: {{item2}}</div>
            </div>
        </div>
    `,
    props: {
        array: [
            [['a000', 'a001'], ['a010', 'a011']],
            [['a100', 'a101'], ['a110', 'a111']],
            [['a200', 'a201'], ['a210', 'a211']]
        ]
    }
});
```

В данном примере на страницу выводится содержимое 3-х мерного массива. Цифровые индексы в именах переменных **index1** и **index2** показывают порядок вложенности директив **~for**.

Пример 16, как не надо делать:

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="element in array">
            <div ~for="element in element">
                <div ~for="element1">Элемент[{{index}},{{index1}},{{index2}}]: {{item}}</div>
            </div>
        </div>
    `,
    props: {
        array: [
            [['a000', 'a001'], ['a010', 'a011']],
            [['a100', 'a101'], ['a110', 'a111']],
            [['a200', 'a201'], ['a210', 'a211']]
        ]
    }
});
```

Это пример работает также как и предыдущий. Однако читаемость кода значительно ниже. Во внешней и в ближайшей к ней внутренней директиве для текущего значения указана переменная с одним именем **element**. Но пример работает, потому что в третьей директиве было учтено автоматическое переименование переменной фреймворком в **element1**. Это уже сильно сбивает с толку. Имена всем остальным переменным цикла, которые в объявлении директив опущены, были назначены по умолчанию. При этом самой внутренней директиве назначены имена с разным индексом. Так у переменной **item** индекс отсутствует, а у переменной **index2** добавлен индекс **2**. Это также сбивает с толку.

```warning_md
**Рекомендация**.
Во избежание путаницы с именами переменных цикла при использовании вложенных директив **~for** рекомендуется или явно указывать все переменные в объявлениях всех директив, тщательно контролируя их уникальность, или во всех случаях использовать значения по умолчанию.
```

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/5grvyQc4-bI?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>

