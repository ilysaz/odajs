```info _md_hideicon
HTML-элементы с директивами **~for** можно вкладывать друг в друга, создавая многомерные повторяющиеся конструкции.
```

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="element, number, , prop in object">
            <div ~for="element">{{prop}}[{{index}}]: {{item}}</div>
        </div>
    `,
    props: {
        object: {
            array_1: ['A', 'B', 'C'],
            array_2: ['D', 'E', 'F']
        }
    }
});
```

В этом примере директива **~for** во внешнем элементе **div** поочередно выбирает все свойства объекта **object**. Эти свойства являются одномерными массивами и служат исходниками данных для директивы **~for** вложенного элемента **div**. Они передаются ему под именем **element**, в результате чего вложенная директива **~for** получает возможность разобрать переданные массивы на отдельные элементы и для каждого из них создать отдельный элемент **div**.

Обратите внимание, что во внешней директиве **~for** дополнительные параметры цикла заданы с нестандартными именами **number** и **prop**. Это сделано специально для исключения конфликта имен параметров внешних и вложенных директив цикла.

```warning_md
Во внешних и вложенных директивах **~for** имена параметров цикла должны обязательно различаться. Иначе параметры внешних директив будут перекрывать параметры вложенных директив с теми же самыми именами по умолчанию: **items**, **item**, **index** и **key**.
```

Например,

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array_1">
            <div ~for="array_2">Элемент[{{index}}]: {{item}} -- Источник: [{{items}}]</div>
        </div>
    `,
    props: {
        array_1: ['A', 'B', 'C'],
        array_2: ['D', 'E', 'F']
    }
});
```

В этом примере во внешней и вложенной директивах **~for** параметры циклов заданы по умолчанию. В результате этого во вложенной директиве используются все параметры внешней дерективы не смотря на то, что в ней указан другой источник данных **array\_2**.

На самом деле, при совпадении имен переменных во внешней и вложенной директивах **~for**, имена вложенных директив модифицируются неявным образом, добавляя в конце имени **1**. Эти модифицированные имена можно спокойно использовать в шаблоне вложенного элемента, как имена его параметров цикла по умолчанию.

Пример 3:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array_1">
            <div ~for="array_2">Элемент[{{index1}}]: {{item1}} -- Источник: [{{items1}}]</div>
        </div>
    `,
    props: {
        array_1: ['A', 'B', 'C'],
        array_2: ['D', 'E', 'F']
    }
});
```

В этом примере, как и в предыдущем, имена параметров внешней и вложенной директивы **~for** заданы по умолчанию, но в шаблоне вложенного элемента **div** используются переменные с модифицированными именами. Так как именно эти имена являются именами параметров вложенной директивы **~for**, то в результате этого на страницу выводятся данные из вложенного источника данных **array\_2**, а не из внешнего **array\_1**.

Если директивы **~for** находятся на одном уровне вложенности, то перекрытие имен их параметров не происходит и для них можно использовать без проблем имена по умолчанию.

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array_1">Элемент[{{index}}]: {{item}} -- Источник: [{{items}}]</div>
        <div ~for="array_2">Элемент[{{index}}]: {{item}} -- Источник: [{{items}}]</div>
    `,
    props: {
        array_1: ['A', 'B', 'C'],
        array_2: ['D', 'E', 'F']
    }
});
```

В этом примере используются две не вложенные друг в друга директивы **~for**, в результате этого никакого конфликта имен их параметров не происходит. Каждая из них обращается к элементам именно своего массива.

```info _md_hideicon
При множественном вложении директив **~for** на первом уровне будут использоваться параметры с именами по умолчанию: **item**, **index**, **items** и **key** соответственно. Для вложенных директив будут созданы переменные с аналогичными именами, к которым будут добавлены цифровые индексы, соответствующие глубине вложенности этих директив: 1, 2 и т.д.
```

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array">
            <div ~for="item">
                <div ~for="item1">Элемент[{{index}},{{index1}},{{index2}}]: {{item2}}</div>
            </div>
        </div>
    `,
    props: {
        array: [
            [['a000', 'a001'], ['a010', 'a011']],
            [['a100', 'a101'], ['a110', 'a111']],
            [['a200', 'a201'], ['a210', 'a211']]
        ]
    }
});
```

В примере для вывода содержимого 3-х мерного массива используются три вложенные директивы **~for**. В этих директивах параметры циклов явно не указаны. В именах переменных **item1**, **item2**, **index1** и **index2** цифровые индексы показывают порядок вложенности директив, в которых эти переменные автоматически были созданы.

Следующий пример показывает, как делать не стоит.

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="element in array">
            <div ~for="element in element">
                <div ~for="element1">Элемент[{{index}},{{index1}},{{index2}}]: {{item}}</div>
            </div>
        </div>
    `,
    props: {
        array: [
            [['a000', 'a001'], ['a010', 'a011']],
            [['a100', 'a101'], ['a110', 'a111']],
            [['a200', 'a201'], ['a210', 'a211']]
        ]
    }
});
```

В нем при одном и том же результате выполнения читаемость кода становится намного ниже. Во-первых, во внешней и последующей внутренней директиве для текущего значения указана переменная с одним именем **element**, поэтому необходимо помнить, что фреймворк автоматически переименует вторую переменную в **element1**. Во-вторых, в третьей директиве **~for** именам переменных **item** и **index2** автоматически присвоены разные числовые индексы, как будто они принадлежат разным директивам. Так, у переменной **item** индекс отсутствует, как будто он был объявлен во внешней директиве, а у переменной **index2** числовой индекс **2** соответствует реальной вложенности директивы.

```faq_md
#### Рекомендация.
Во избежание путаницы с именами параметров цикла при использовании вложенных директив **~for** рекомендуется либо всегда  использовать только значения по умолчанию, либо явно указывать имена всех параметров во всех директивах, вручную контролируя их уникальность.
```

Если во внешних и вложенных директивах **~for** имена параметров цикла явно не заданы или они заданы только у некоторых параметров, то необъявленные имена формируются по следующим правилам:

- за основу берутся имена **item**, **index**, **items** или **key**;
- затем проверяется использование каждого имени в директивах, расположенных выше по уровню;
- если соответствующее имя уже используется, то к основе имени добавляют суффикс **1**;
- если имя с суффиксом **1** уже существует, то к основе имени добавляется суффикс **2**, и так далее, пока не будет сформировано уникальное имя для данного параметра.

Если в директивах, расположенных на разных уровнях, явно заданы одинаковые имена параметров цикла, то фреймворк изменит имя во внутренней директиве. За основу берется имя объявленного параметра и к нему добавляется суффикс **1**, **2** и так далее, пока не будет создано уникальное имя.

Автоматическое назначение имен параметрам цикла и автоматическое их переименование позволяет избежать краха компонента в процессе использования вложенных директив **~for**, однако это делает код компонента сложным для понимания и усложняет процесс поиска функциональных ошибок в нем.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/OG6gJ5yLikM?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>
