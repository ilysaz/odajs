Директива **~for** используется для создания последовательности HTML-элементов на основе массива данных.

```warning_md
В этой директиве обязательно должно быть указано как имя самого массива, так и ссылка на его текущий элемент.
```
Пример 1:
```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item in items">Элемент: {{item}} </div>
    `,
    props: {
        items: [
            'A', 'B', 'C'
        ]
    }
});
```

В приведенном примере из массива **items** будут последовательно извлечены все элементы и для каждого из них будет создан свой собственный HTML-элемент **div**, в котором будет выводиться значение текущего элемента массива с помощью указателя на него **item**.

В расширенной форме записи, помимо значения текущего элемента массива, можно указать еще и ссылку на его индекс.

Пример 2:
```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index in items">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        items: [
            'A', 'B', 'C'
        ]
    }
});
```

В этом примере для ссылки на индекс элемента массива использовалось имя **index**.

```info_md
Кроме структуры цикла **for...in**, можно использовать структуру **for...of**.
```

Пример 3:
```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index of items">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        items: [
            'A', 'B', 'C'
        ]
    }
});
```

Результат выполнения этого примера будет точно таким же, как и у предыдущего.

Кроме этого, существует упрощенная форма записи директивы **~for**, в которой можно не указывать ссылки на элемент массива и его индекс.

Пример 4:
```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="items">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        items: [
            'A', 'B', 'C'
        ]
    }
});
```

В этом случае в значение директивы будет достаточно записать только имя самого массива, а имена ссылок **item** и **index** будут добавлены автоматически. В результате этого обращаться к ним можно будет точно так же, как и при полной форме записи.

```info_md
При использовании упрощенной формы имена ссылок **item** и **index** задаются по умолчанию. Если у компонента уже существуют элементы с такими же именами, то именно эти элементы будут использоваться в качестве параметров цикла вместо ссылок по умолчанию.
```

Пример 5:
```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="items">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        items: [
            'A', 'B', 'C'
        ],
        item: "Ошибка",
        index: -1
    }
});
```

В этом примере значения параметров **item** и **index** не будут меняться в цикле. Они перекрываются значениями свойств самого компонента с теми же самыми именами.

```warning_md
 По этой причине крайне нежелательно использовать имена **item** и **index** для свойств, методов или других элементов компонента.
```

С помощью директивы **~for** можно вывести последовательность целых чисел, начиная с 1, если значение, указанное в JS-выражении, можно привести к целому типу.

Пример 6:
```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="count">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        count: 10
    }
});
```

Вычисленное значение директивы в этом случае определяет последнее число в генерируемой последовательности. В данном примере это значение равно 10.

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/5grvyQc4-bI?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>

Директива **~for** используется для создания последовательности однотипных HTML-элементов на основе заданного источника данных.

В качестве источника данных могут выступать: массивы, объекты или любые JavaScript-выражения, значение которых можно представить в виде массива или объекта.

В общем случае директива **~for** имеет следующий синтаксис:

```info md_hideicon
**~for="item, index, items, key in dataSource"**
```

В процессе ее выполнения последовательно извлекаются все элементы  указанного источника (**dataSource**) и на их основе создает очередной HTML-элемент.

При формировании тела каждого HTML-элемента можно использовать дополнительные параметры, которые могут быть указаны в этой директиве. К которым относятся:

1. **item** – значение текущего элемента источника данных.

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="item in array">Элемент: {{item}}</div>
        `,
        props: {
            array: ['A', 'B', 'C']
        }
    });
    ```

    В этом примере из массива **array** последовательно извлекаются все элементы, и для каждого из них создается свой собственный HTML-элемент **div**. В его теле название текущего элемента массива выводится с помощью переменной **item**, которая передается ему автоматически из заголовка директивы **~for**.

1. Переменная цикла **index** содержит порядковый номер текущего элемента данных в источнике данных.

    Если источник данных является массивом, то эта переменная фактически является индексом текущего элемента массива.

    Пример 2:

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="item, index in array">Элемент[{{index}}]: {{item}}</div>
        `,
        props: {
            array: ['A', 'B', 'C']
        }
    });
    ```

    Из этого примера видно, что индексация элементов массива как обычно начинается с нуля.

1. Переменная цикла **items** является указателем на сам источник данных, на основе которого формируются все однотипные HTML-элементы.

    Если источником данных является объект или массив, то переменная **items** будет просто ссылаться на эти объекты.

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="item, index, items in array">Элемент[{{index}}]: {{item}} - array: {{items}}</div>
        `,
        props: {
            array: [
                'A', 'B', 'C'
            ]
        }
    });
    ```

    Если источник данных будет является JavaScript-выражением, то переменная **items** будет ссылаться на внутренний источник данных, сформированный  фреймворк автоматически специально для этой цели.

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="item, index, items in ['A', 'B', 'C']">Элемент[{{index}}]: {{item}} - array: {{items}}</div>
        `
    });
    ```

    Этот пример аналогичен предыдущему, за исключением того, что исходный источник данных формируется в директиве **~for** с помощью отдельного JavaScript-выражения.

1. Переменная цикла **key** содержит имя текущего свойства объекта, если источник данных является объектом.

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="item, index, items, key in object">{{index+1}}-е свойство {{key}}: {{item}} -- object: {{JSON.stringify(items)}}</div>
        `,
        props: {
            object: {
                prop1:'A', prop2:'B', prop3:'C'
            }
        }
    });
    ```

    Переменная **index** в этом пример выводит порядковый индекс свойства объекта, а переменная **key** содержит имя этого свойства.

    Если источник данных является массивом, то переменная **key** будет содержать значение индекса элемента массива, и фактически будет полностью дублировать значение переменной **index**.

    Например,

    ```javascript _run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <div ~for="item, index, items, key in array">Индекс {{index}}- элемент[{{key}}]: {{item}} -- array: {{items}}</div>
        `,
        props: {
            array: {
                prop1:'A', prop2:'B', prop3:'C'
            }
        }
    });
    ```

    Как видно значения переменных **key** и **index** в этом примере полностью совпадают друг с другом.

```info_md
Кроме структуры цикла **for...in**, можно использовать структуру **for...of**.
```

Например,

```javascript _run_edit_[my-component.js]
ODA({
        is: 'my-component',
        template: `
            <div ~for="item, index, items, key in array">Индекс {{index}}- элемент[{{key}}]: {{item}} -- array: {{items}}</div>
        `,
        props: {
            array: ['A', 'B', 'C']
        }
    });
```

Результат выполнения этого примера будет точно таким же, как и у предыдущего, так как эти две директивы функционально абсолютно одинаковые.

```info_md
    Если при использовании директивы **~for** не указать какую-либо переменную, то она будет создана автоматически с имен по умолчанию: **item**, **index**, **items** или **key** соответственно.
```

Например,

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items, key in array">Индекс {{index}}- элемент[{{key}}]: {{item}} -- array: {{items}}</div>
    `,
    props: {
        array: ['A', 'B', 'C']
    }
});
```

В этом примере в директиве **~for** указано только одно имя источника данных, однако в теле элемента все переменные цикла **item**, **index**, **items** и **key** можно использовать как обычно. Они будут созданы автоматически.

```warning_md
Если компонент имеет внутренние свойства с такими же именами как у переменных цикла, то переменные цикла не будут создаваться автоматически. Вместо них будут использоваться заданные значения свойств компонента.
```

Например,

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items, key in array">Индекс {{index}}- элемент[{{key}}]: {{item}} -- array: {{items}}</div>
    `,
    props: {
        array: array: ['A', 'B', 'C'],
        item: 'ошибка',
        index: 'N',
        items: 'неправильная ссылка',
        key: 'error'
    }
});
```

Для использования стандартных переменных цикла в этом случае придется задавать для них другие имена.

Например,

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item1, index1, items1, key1 in array">Индекс {{index1}}- элемент[{{key1}}]: {{item1}} -- array: {{items1}}</div>
    `,
    props: {
        array: array: ['A', 'B', 'C'],
        item: 'ошибка',
        index: 'N',
        items: 'неправильная ссылка',
        key: 'error'
    }
});
```

В этом примере имена переменных цикла **item1**, **index1**, **items1** и **key1** уже не пересекаются с именам свойства самого компонента.

```info_md
Область действия переменных цикла ограничена HTML-элементом, в котором объявлена директива **~for**. На уровне компонента переменные цикла недоступны.
```

Пример 8:

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array">Элемент[{{index}}}]: {{this.item}}</div>
    `,
    props: {
        array: array: ['A', 'B', 'C'],
    }
});
```

В этом примере мы пытаемся обратиться к переменной цикла **item**, используя указатель на компонент **this**. Но поскольку эта переменная на уровне компонента не определена, то ее значение будет **undefined**.

Если необходимо использовать переменную цикла за пределами HTML-элемента, в котором она объявлена, то ее необходимо передать методу в качестве параметра.

Пример 9:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="item, index, items, key in object">{{key}}: {{getItem(items,key)}}</div>
    `,
    props: {
        object: {
            prop1:'A', prop2:'B', prop3:'C'
        }
    },
    getItem(obj, prop) {
        return obj[prop];
    }
});
```

В этом примере текущее значение для директивы **~for** формируется методом **getItem**. В качестве параметров этому методу передаются источник данных из переменной **items** и имя текущего свойства из переменной **key**.

Директива **~for** обрабатывает все элементы из источника данных, даже если эти элементы неопределенны.

Пример 10:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        array: [
            'A', , 'C'
        ]
    }
});
```

В этом примере в объявлении массива **array** пропущен элемент с индексом **1**. Однако фреймворк все равно создает для него HTML-элемент **div**, используя значение **undefind**.

Чтобы исключить создание HTML-элементов для отсутствующих элементов исходных данных, директиву **~for** необходимо использовать совместно с директивой **~if**, параметром которой служит текущий элемент данных.

Пример 11:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array" ~if="item">Элемент[{{index}}]: {{item}}</div>
    `,
    props: {
        array: [
            'A', , 'C'
        ]
    }
});
```

Этот пример аналогичен предыдущему, за исключением того, что неопределенный элемент с индексом **1** из массива **array** теперь отфильтровывается директивой **~if="item"**.

С помощью директивы **~for** можно вывести последовательность целых чисел, начиная с 1, если значение, указанное в источнике данных, можно привести к целому типу. Последнее число в генерируемой последовательности определяется значением источника данных.

Пример 12:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="Math.floor(count)">Элемент[{{index}}]: {{item}} – источник данных: [{{items}}]</div>
    `,
    props: {
        count: 7.1
    }
});
```

В данном примере в качестве источника данных используется JS-выражение, преобразующее вещественное число к целому типу. В данном примере это выражении равно 7, поэтому директива создает семь элементов **div**. Переменная цикла **items** используется для демонстрации содержимого реального источника данных, с которым оперирует директива. В данном примере это массив с последовательностью целых чисел от 1 до 7.

Если источником данных является символьная строка, то директива **~for** обрабатывает ее как массив отдельных символов.

Пример 13:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="count">Элемент[{{index}}]: {{item}} – источник данных: [{{items}}]</div>
    `,
    props: {
        count: "Привет!"
    }
});
```

В данном примере в качестве источника данных используется символьная строка **"Привет!"**. Директива раскладывает ее на отдельные символы. Переменная цикла **items** используется для демонстрации содержимого реального источника данных, с которым оперирует директива.















```info_md
HTML-элементы с директивами **~for** можно вкладывать друг в друга, создавая многомерные конструкции.
```

Пример 12:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="element, number, sourse, prop in object">
            <div ~for="element">{{prop}}[{{index}}]: {{item}}</div>
        </div>
    `,
    props: {
        object: {
            array_1: ['A', 'B', 'C'],
            array_2: ['D', 'E', 'F']
        }
    }
});
```

В этом примере директива **~for** во внешнем элементе **div** поочередно выбирает свойства объекта **object**, которые являются одномерными массивами. Затем эти массивы через переменную цикла **element** передаются директиве **~for** во вложенном элементе **div**. Вторая директива разбирает массивы на отдельные значения и выводит их на web-страницу.

Обратите внимание, что переменная цикла **element** из внешней директивы используется в качестве источника данных во второй директиве. Во внешней директиве пришлось явно указать все переменные цикла, хотя в шаблоне используются только первая и последняя переменные **element** и **prop**. Переменные цикла во внутренней директиве не заданы, в шаблоне используются переменные **item** и **index**, создаваемые фреймворком по умолчанию.

```warning_md
Во внешних и вложенных директивах **~for** имена переменных цикла должны обязательно различаться. Иначе переменные внешних директив будут перекрывать переменные внутренних директив.
```

Пример 13:

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array_1">
            <div ~for="item, index, items in array_2">Элемент[{{index}}]: {{item}} -- Источник: {{items}}</div>
        </div>
    `,
    props: {
        array_1: ['A', 'B', 'C'],
        array_2: ['D', 'E', 'F']
    }
});
```

В этом примере во внешней директиве **~for** переменные цикла не указаны явно, поэтому их имена заданы по умолчанию **item**, **index** и **items**. Во вложенной директиве **~for** переменные цикла указаны явно и имеют такие же имена, т.е. имена переменных перекрываются. В результате, хотя для вложенной директивы в качестве источника данных указан массив **array_2**, на страницу выводятся только данные из массива **array_1**, указанного во внешней директиве.

На самом деле, в случае совпадения имен переменных во внешней и вложенной директивах **~for**, фреймворк неявным образом модифицирует имена переменных во вложенной директиве, добавляя в конце имени символ **1**. Эти модифицированные имена можно использовать в шаблоне элемента.

Пример 14:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array_1">
            <div ~for="item, index, items in array_2">Элемент[{{index1}}]: {{item1}} -- Источник: {{items1}}</div>
        </div>
    `,
    props: {
        array_1: ['A', 'B', 'C'],
        array_2: ['D', 'E', 'F']
    }
});
```

В этом примере, как и в предыдущем, во внешней и вложенной директивах имена переменных цикла совпадают. Но в шаблоне вложенного элемента **div** используются переменные, к именам которых добавлен символ **1**. Эти переменные не объявлены во вложенной директиве, более того в директиве используются совсем другие имена, однако именно эти необъявленные переменные фреймворк использует в качестве переменных цикла. В результате на web-страницу выводятся данные из массива **array_2**, который указан источником данных во вложенной директиве.

```info_md
Для минимизации объема кода и ускорения процесса программирования при создании иерархии вложенных директив **~for** можно опустить все параметры, указав только источник данных. В этом случае для внешней директивы фреймворк автоматически создаст переменные цикла с именами **item**, **index**, **items** и **key** соответственно. Для вложенных директив будут созданы переменные с аналогичными именами, к которым добавлены цифровые индексы, соответствующие глубине вложенности.
```

Пример 15:

```javascript _run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="array">
            <div ~for="item">
                <div ~for="item1">Элемент[{{index}},{{index1}},{{index2}}]: {{item2}}</div>
            </div>
        </div>
    `,
    props: {
        array: [
            [['a000', 'a001'], ['a010', 'a011']],
            [['a100', 'a101'], ['a110', 'a111']],
            [['a200', 'a201'], ['a210', 'a211']]
        ]
    }
});
```

В данном примере на страницу выводится содержимое 3-х мерного массива. Цифровые индексы в именах переменных **index1** и **index2** показывают порядок вложенности директив **~for**.

Пример 16, как не надо делать:

```javascript _error_run_edit_[my-component.js]
ODA({
    is: 'my-component',
    template: `
        <div ~for="element in array">
            <div ~for="element in element">
                <div ~for="element1">Элемент[{{index}},{{index1}},{{index2}}]: {{item}}</div>
            </div>
        </div>
    `,
    props: {
        array: [
            [['a000', 'a001'], ['a010', 'a011']],
            [['a100', 'a101'], ['a110', 'a111']],
            [['a200', 'a201'], ['a210', 'a211']]
        ]
    }
});
```

Это пример работает также как и предыдущий. Однако читаемость кода значительно ниже. Во внешней и в ближайшей к ней внутренней директиве для текущего значения указана переменная с одним именем **element**. Но пример работает, потому что в третьей директиве было учтено автоматическое переименование переменной фреймворком в **element1**. Это уже сильно сбивает с толку. Имена всем остальным переменным цикла, которые в объявлении директив опущены, были назначены по умолчанию. При этом самой внутренней директиве назначены имена с разным индексом. Так у переменной **item** индекс отсутствует, а у переменной **index2** добавлен индекс **2**. Это также сбивает с толку.

```warning_md
**Рекомендация**.
Во избежание путаницы с именами переменных цикла при использовании вложенных директив **~for** рекомендуется или явно указывать все переменные в объявлениях всех директив, тщательно контролируя их уникальность, или во всех случаях использовать значения по умолчанию.
```

<div style="position:relative;padding-bottom:48%; margin:10px">
    <iframe src="https://www.youtube.com/embed/5grvyQc4-bI?start=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen
    	style="position:absolute;width:100%;height:100%;"></iframe>
</div>

