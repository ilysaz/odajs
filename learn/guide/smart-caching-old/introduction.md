Фреймворк имеет встроенные механизмы кэширования результатов выполнения геттеров и методов. Это позволяет снизить требования к вычислительным ресурсам и повысить отзывчивость web-страницы.

Кеширование основано на принципе, что если состояние компонента не изменилось, то и результат выполнения геттеров и методов не изменится.

Изменением состояния компонента считается изменение значений свойств, объявленных явно в прототипе компонента. Изменения значений свойств, созданных в процессе работы компонента, не считаются изменениями состояния компонента. Также на состояние компонента не влияет изменение значений свойств объектов и элементов массивов.

Механизм кэширования работает следующим образом:

1. на этапе создания компонента фреймворк анализирует зависимость геттеров и методов от свойств этого компонента;

1. при первом выполнении геттера или метода возвращенное значение сохраняется в кэше;

1. при последующих вызовах геттера или методов проверяется наличие изменений в значениях свойств, от которых он зависит. Если изменений не произошло, то геттер или методы не выполняются, а значение берется из кэша. Если изменения произошли, то расчет выполняется заново и новое значение опять запоминается в кэше.

Рассмотрим пример, в котором геттер и метод должны вызываться при каждом рендеринге web-страницы браузером:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
        <div ~text="'Время из подстановки: '+(new Date).toLocaleTimeString()"></div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});
```

В примере на экран должно выводиться текущее время с точностью до миллисекунд. Для получения времени используются геттер **getterTime** и метод **methodTime**, а также текстовая подстановка с помощью директивы **~text**. Но на экран время выводится только при загрузке страницы и больше не обновляется. Это происходит потому, что компонент не меняет своего состояния (не изменяются значения свойств) и, следовательно, фреймворку незачем его пересчитывать.

```faq_md
Точнее, время в примере не обновляется, пока Вы на него смотрите. Однако если с помощью полосы вертикальной прокрутки Вы временно уберете зону с результатами примера за пределы области просмотра, а затем вернете ее обратно, то увидите, что время, возвращаемое методом **methodTime** и текстовой подстановкой, изменилось и соответствует текущему.

Это связано с тем, что при перемещении части web-страницы с компонентом в область просмотра сбрасывается кэш методов компонента.
```

Измените значение в строке ввода. При вводе или удалении каждого символа текущее время обновляется, но только для значений, получаемых из метода и текстовой подстановки, а значение геттера не изменяется.

В коде метода отсутствует непосредственное обращение к свойству **change**, но кэш методов и подстановок очищается при любом изменении состояния компонента, поэтому при каждом изменении строки происходит выполнение метода **methodTime** и вычисление подстановки **~text**.

Примечание — Значения вычисляемых выражений, указанных в HTML-шаблоне компонента кэшируются так же как и значения методов компонента. Далее в этой статье для краткости изложения говорится только о кэшировании методов компонента.

Добавим в геттер **getterTime** обращение к свойству **change**:

```javascript_run_line_edit_console_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                this.change;
                var d = new Date();
                console.log('getter: ' + d.getSeconds() + '.' + d.getMilliseconds());
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        console.log('method: ' + d.getSeconds() + '.' + d.getMilliseconds());
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});
```

Измените значение в строке ввода. Теперь и геттер и метод обновляют время на экране при каждом добавлении или удалении символа. Обратите внимание, что в коде геттера свойство **change** просто упоминается, никаких операций с ним не производится. То есть для сброса кэша геттера и его выполнения требуется изменить значение используемого в нем свойства компонента.

Метод **methodTime** и геттер **getterTime** для контроля записывают метки времени в консоль. Эти метки показывают, что при изменении свойства **change** геттер выполняется один раз, а метод выполняется два раза. Причем первый раз метод выполняется почти одновременно с геттером. Это является реакцией на изменение состояния компонента.

Второй раз метод выполняется, судя по задержке, в следующем цикле рендеринга страницы. Это является реакцией на вызов геттера. Так как геттер не изменяет состояния компонента, это значит, что сам факт вызова геттера сбрасывает кэш методов.

Примечание — Содержимое консоли можно посмотреть в браузере в **Инструментах разработчика** или открыть непосредственно под примером нажав на кнопку &sum; в правом верхнем углу редактора с текстом примера.
