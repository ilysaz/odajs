Фреймворк имеет встроенные механизмы кэширования результатов выполнения геттеров и методов. Это позволяет снизить требование к вычислительным ресурсам и повысить отзывчивость web-страницы.

Кеширование основано на принципе, что если состояние компонента не изменилось, то и результат выполнения геттеров и методов не изменится.

Изменением состояния компонента считается изменение значений свойств, объявленных явно в прототипе компонента. Изменения значений свойств, созданных в процессе работы компонента, не считаются изменениями состояния компонента. Также на состояние компонента не влияет изменение значений свойств объектов и элементов массивов.

Механизм кэширования работает следующим образом:

1. на этапе создания компонента фреймворк анализирует зависимость геттеров и методов от свойств этого компонента;

1. при первом выполнении геттера или метода возвращенное значение запоминается в кэше;

1. при последующих вызовах геттера или метода проверяется наличие изменений в значениях свойств, от которых он зависит. Если изменений не произошло, то геттер или метод не выполняются, а значение берется из кэша. Если изменения произошли, расчет выполняется заново и новое значение опять запоминается в кэше.

Рассмотрим пример, в котором геттер и метод должны вызываться при каждом рендеринге web-страницы браузером:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
        <div ~text="'Время из подстановки: '+(new Date).toLocaleTimeString()"></div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});
```

В примере на экран должно выводиться текущее время с точностью до миллисекунд. Для получения времени используются геттер **getterTime** и метод **methodTime**, а также текстовая подстановка с помощью директивы **~text**. Но на экран время выводится только при загрузке страницы и больше не обновляется. Это происходит потому, что компонент не меняет своего состояния (не изменяются значения свойств) и, следовательно, фреймворку незачем его пересчитывать.

```faq_md
Точнее, время в примере не обновляется, пока Вы на него смотрите. Однако если с помощью полосы вертикальной прокрутки Вы временно уберете зону с результатами примера за пределы области просмотра, а затем вернете ее обратно, то увидите, что время, возвращаемое методом **methodTime** и текстовой подстановкой, изменилось и соответствует текущему.

Это связано с тем, что при перемещении части web-страницы с компонентом в область просмотра сбрасывается кэш методов компонента.
```

Измените значение в строке ввода. При вводе или удалении каждого символа текущее время обновляется, но только для значений, получаемых из метода и текстовой подстановки, а значение геттера не изменяется.

В коде метода отсутствует непосредственное обращение к свойству **change**, но кэш методов и подстановок очищается при любом изменении состояния компонента, поэтому при каждом изменении строки происходит выполнение метода **methodTime** и вычисление подстановки **~text**.

Примечание – Значения вычисляемых выражений, указанных в HTML-шаблоне компонента кэшируются также как и значения методов компонента. Далее в этой статье для краткости изложения говорится только о кэшировании методов компонента.

Добавим в геттер **getterTime** обращение к свойству **change**:

```javascript_run_line_edit_console_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                this.change;
                var d = new Date();
                console.log('getter: ' + d.getSeconds() + '.' + d.getMilliseconds());
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        console.log('method: ' + d.getSeconds() + '.' + d.getMilliseconds());
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});
```

Измените значение в строке ввода. Теперь оба и геттер, и метод обновляют время на экране при каждом добавлении или удалении символа. Обратите внимание, что в коде геттера свойство **change** просто упоминается, никаких операций с ним не производится. То есть для сброса кэша геттера и его выполнения требуется изменить значение используемого в нем свойства компонента.

Метод **methodTime** и геттер **getterTime** для контроля записывают метки времени в консоль. Эти метки показывают, что при изменении свойства **change** геттер выполняется один раз, а метод выполняется два раза. Причем первый раз метод выполняется почти одновременно с геттером. Это является реакцией на изменение состояния компонента.

Второй раз метод выполняется, судя по задержке, в следующем цикле рендеринга страницы. Это является реакцией на вызов геттера. Так как геттер не изменяет состояния компонента, это значит, что сам факт вызова геттера сбрасывает кэш методов.

Примечание – Содержимое консоли можно посмотреть в браузере в **Инструментах разработчика** или открыть непосредственно под примером нажав на кнопку &sum; в правом верхнем углу редактора с текстом примера.

Используя директиву **@tap** добавим в строку ввода реакцию на событие нажатия:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change" @tap>
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                this.change;
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});
```

Теперь текущее время обновляется и при щелчке мышью по строке ввода, но только для значения, получаемого из метода, а значение геттера не изменяется. Это происходит потому, что попытка перехвата события внутри отдельных элементов компонента сбрасывает кэш методов. Обратите внимание, что в директиве **@tap** не указано никакого обработчика события, то есть важен сам факт попытки перехвата.

Однако, перехват события для всего компонента с помощью атрибута **listeners** кэш методов сбрасывать не будет:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <div ref="div">Нажми на меня левой или правой кнопкой мыши</div>
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    props: {
        getterTime: {
            get() {
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    },
    listeners: {
        tap() {
            this.$refs.div.textContent = "Нажата левая кнопка";
        },
        contextmenu() {
            this.$refs.div.textContent = "Нажата правая кнопка";
        }
    }
});
```

В примере вызов обработчиков нажатий клавиш мыши не сбрасывает кэш ни геттера, ни методов. Сами обработчики не изменяют состояние компонента, записывая выводимый текст непосредственно в элемент **div**. Поэтому текущее время выводится только при загрузке страницы и больше не обновляется.

Аналогично, перехват событий нажатия клавиш с помощью атрибута **keyBindings** кэш методов сбрасывать не будет:

```javascript_run_line_edit_[my-component.js]_h=76_
ODA({
    is: 'my-component',
    template: `
        <div ref="div">Нет нажатых клавиш</div>
        <input placeholder='нажмите клавиши "a" и "b"'>
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    props: {
        getterTime: {
            get() {
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    },
    keyBindings: {
        a: '_keyA',
        b: '_keyB'
    },
    _keyA() {
        this.$refs.div.textContent = 'Нажата клавиша "a"';
    },
    _keyB() {
        this.$refs.div.textContent = 'Нажата клавиша "b"';
    }
});
```

В примере вызов обработчиков нажатий клавиш "a" и "b" не сбрасывает кэш ни геттера, ни методов. Сами обработчики не изменяют состояние компонента, записывая выводимый текст непосредственно в элемент **div**. Поэтому текущее время выводится только при загрузке страницы и больше не обновляется.

Аналогично, перехват событий с помощью метода **listen** кэш методов сбрасывать не будет:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <div ref="div">Щелкни по мне</div>
        <div>Время из геттера: {{getterTime}}</div>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    props: {
        getterTime: {
            get() {
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    },
    ready() {
        this.listen('tap', 'onTap');
    },
    onTap() {
        this.$refs.div.textContent = (this.$refs.div.textContent=='еще щелчок')? 'и снова щелчок': 'еще щелчок';
    }
});
```

В примере вызов обработчиков нажатий левой клавиши мыши не сбрасывает кэш ни геттера, ни методов. Сами обработчики не изменяют состояние компонента, записывая выводимый текст непосредственно в элемент **div**. Поэтому текущее время выводится только при загрузке страницы и больше не обновляется.

```warning_md
С осторожностью изменяйте значения свойств компонента в методе, вызываемом при рендеринге web-страницы. Такое изменение очищает кэш методов и приводит к их выполнению при следующем рендеринге web-страницы.
```

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <div>Счетчик из геттера: {{getterCount}}</div>
        <div>Счетчик из метода: {{methodCount()}}</div>
    `,
    props: {
        count1: 0,
        count2: 0,
        getterCount: {
            get() {
                return ++this.count1;
            }
        }
    },
    methodCount() {
        return ++this.count2;
    }
});
```

В примере видно, что изменение свойства **count2** в методе **methodCount** приводит к очистке кэша методов и выполнению метода при каждом рендеринге страницы. В тоже время изменение свойства **count1** в геттере не приводит к очистке кэша геттера и повторному выполнению, поэтому счетчик **count1** инкрементируется только один раз при загрузке страницы.

```warning_md
С осторожностью используйте для изменения значения одного и того же свойства несколько геттеров. Это может привести к взаимному сбросу кэшей этих геттеров, и их непрерывному выполнению.
```

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <div>Счетчик из геттера 1: {{getterCount1}}</div>
        <div>Счетчик из геттера 2: {{getterCount2}}</div>
    `,
    props: {
        count: 0,
        getterCount1: {
            get() {
                return ++this.count;
            }
        }
    },
    get getterCount2() {
            return ++this.count;
    }
});
```

В примере изменение свойства **count** в геттере **getterCount1** сбрасывает кэш геттера **getterCount2**, что приводит к его выполнению. В этом геттере свойство **count** опять изменяется и сбрасывает кэш геттера **getterCount1**. Фактически такое использование свойства **count** отключает кэши обоих геттеров и приводит к их выполнению при каждом рендеринге страницы.

В коде геттера обязательно должно быть обращение к какому-либо свойству, которое сбрасывает кэш гетера, иначе геттер превращается в константу. Обращение к свойству не обязательно должно быть непосредственно в коде геттера, обращение может находиться в одном из вызываемых геттером методов.

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Время из геттера: {{getterTime}}</div>
    `,
    props: {
        change: "Измени меня",
        getterTime: {
            get() {
                this.hiddenChange();
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    hiddenChange() {
        this.change;
    }
});
```

В примере геттер **getterTime** в своем коде не содержит обращение к счетчику **change**, но он вызывает метод **hiddenChange**, в котором такое обращение присутствует, поэтому при любом изменении текста в строке ввода обновляется текущее время на странице.

```warning_md
Чтобы свойство начало управлять сбросом кэша геттера, необходимо при выполнении гетера обратиться к нему хотя бы один раз.
```

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <button @tap="permission=!permission">Permit={{permission}}</button>
        <div>Время из геттера: {{getterTime}}</div>
    `,
    props: {
        count: 0,
        permission: false,
        getterTime: {
            get() {
                if(this.permission) this.count;
                var d = new Date();
                return d.toLocaleTimeString() + '.' + d.getMilliseconds();
            }
        }
    },
    attached() {
        setInterval( ()=>{++this.count}, 1000);
    }
});
```

Сразу после загрузки страницы геттер **getterTime** выполняется один раз и время на экране больше не обновляется. При первом выполнении геттера обращение к свойству **count** было заблокировано условным оператором. Нажмите на кнопку **Permit**, чтобы заставить геттер выполниться второй раз из-за изменения значения свойства **permission**. При этом в условном операторе произойдет обращение к свойству **count**. Теперь при каждом изменении счетчика **count** кэш геттера сбрасывается и происходит выполнение геттера, что видно по изменению времени на странице. Если повторно нажать на кнопку **Permit**, то условный оператор опять заблокирует обращение к свойству **count**, однако отсчет времени не прекратиться, так как свойство **count** уже зарегистрировано для управления кэшем.

Изменение состояния одного независимого компонента не влияет на очистку кэша методов другого независимого компонента.

Например:

```html run_line_edit_h=46_
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Welcome to ODA.js</title>
        <script type="module" src="https://cdn.jsdelivr.net/gh/odajs/oda-framework/oda.js"></script>
    </head>
    <body>
        <my-count></my-count>
        <my-time></my-time>
        <script type="module">
            ODA({
                is: 'my-time,
                template: `
                    <div>Время из метода: {{methodTime()}}</div>
                `,
                methodTime() {
                    var d = new Date();
                    return d.toLocaleTimeString() + '.' + d.getMilliseconds();
                }
            });

            ODA({
                is: 'my-count',
                template: `
                    <button @tap="++count">Счетчик: {{count}}</button>
                `,
                count: 0
            });
        </script>
    </body>
</html>
```

В примере время, выводимое компонентом **my-component** при нажатии на кнопку **Счетчик**, не обновляется, потому что состояние компонента не изменяется. Изменение состояния компонента **my-count** на него не влияет, так оба компонента взаимно независимые.

Если объединить несколько компонентов в одном компоненте, то кэш методов у них становится общим. Следовательно, изменение состояния любого из объединенных компонентов влияет на выполнение методов во всех остальных компонентах.

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <my-change></my-change>
        <my-time></my-time>
    `
});

ODA({
    is: 'my-time',
    template: `
        <div>Время из метода: {{methodTime()}}</div>
    `,
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});

ODA({
    is: 'my-change',
    template: `
        <input ::value="change">
    `,
    change: "Измени меня"
});
```

В примере изменение текста в строке ввода в компоненте **my-change** изменяет состояние всего компонента **my-component**, поэтому сбрасывается кэш методов в компоненте **my-time**, и время на странице обновляется.

Кэш методов становится общим также в случае включения одного компонента в состав другого.

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    template: `
        <my-change></my-change>
        <div>Время из метода: {{methodTime()}}</div>
    `,
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});

ODA({
    is: 'my-change',
    template: `
        <input ::value="change">
    `,
    change: "Измени меня"
});
```

В примере изменение текста в строке ввода в подчиненном компоненте **my-change** изменяет состояние всего компонента **my-component**, поэтому время на странице обновляется.

Кэш методов становится общим также в случае наследования компонентов.

Например:

```javascript_run_line_edit_[my-component.js]_h=46_
ODA({
    is: 'my-component',
    extends: 'my-change',
    template: `
        <div>Время из метода: {{methodTime()}}</div>
    `,
    methodTime() {
        var d = new Date();
        return d.toLocaleTimeString() + '.' + d.getMilliseconds();
    }
});

ODA({
    is: 'my-change',
    template: `
        <input ::value="change">
    `,
    change: "Измени меня"
});
```

В примере изменение текста в строке ввода в родительском компоненте **my-change** изменяет состояние всего компонента **my-component**, поэтому время на странице обновляется.

```info_md
Кэш методов становится общим и сбрасывается одновременно для всех компонентов, объединенных в одном компоненте, независимо от метода объединения.
```

Изменение значений свойств объектов и элементов массивов не сбрасывает кэши геттеров и методов.

Например:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change1.a">
        <input ::value="change2[0]">
        <div>Значение из геттера: {{getterChange}}</div>
        <div>Значение из метода: {{methodChange()}}</div>
    `,
    props: {
        getterChange: {
            get() {
                this.change2[0];
                return this.change1.a;
            }
        }
    },
    change1: { a:"Измени свойство объекта" },
    change2: ["Измени элемент массива"],
    methodChange() {
        return this.change2[0];
    },
});
```

В примере изменения значений свойства объекта **change1.a** и элемента массива **change2[0]** с помощью строк ввода не сбрасывают кэш методов и кэш геттера, поэтому геттер **getterChange** и метод **methodChange** выполняются один раз при загрузке страницы.

Если свойство компонента не было явно объявлено в прототипе компонента, то изменение его значения не сбрасывает кэш ни геттеров, ни методов.

Например:

```javascript_run_line_edit_[my-component.js]_h=60_
ODA({
    is: 'my-component',
    template: `
        <input ::value="change">
        <div>Значение из геттера: {{getterChange}}</div>
        <div>Значение из метода: {{methodChange()}}</div>
    `,
    props: {
        getterChange: {
            get() {
                return this.change;
            }
        }
    },
    methodChange() {
        return this.change;
    },
    created() {
        this.change = this.change || "Измени меня";
    }
});
```

В примере свойство **change** создается в хуке **created**, поэтому изменение его значения в строке ввода не сбрасывает кэш геттера **getterChange** и метода **methodChange**. В результате и геттер, и метод выполняются один раз при загрузке страницы.

Кратко повторим особенности работы кэша геттера и методов:

1. Кеширование основано на принципе, что если состояние компонента не изменилось, то и результат выполнения геттеров и методов не изменится.

1. Изменением состояния компонента считается изменение значений свойств, объявленных явно в прототипе компонента. 

1. Изменения значений свойств, созданных в процессе работы компонента, не считаются изменениями состояния компонента.

1. Изменение значений отдельных свойств объектов и элементов массивов, объявленных в прототипе, не считаются изменениями состояния компонента.

1. Кэш методов очищается при любом изменении состояния компонента.

1. Сам факт вызова любого геттера сбрасывает кэш методов.

1. Кеш методов сбрасывается при попадании части web-страницы с компонентом в область просмотра.

1. Кеш методов сбрасывается при перехвате событий элементов компонента директивой **@** (например, @tap, @click, и т. п.). Кеш методов **НЕ** сбрасывается при перехвате событий компонента обработчиками, заданными с помощью атрибутов **listeners**, **keyBindings** и метода **listen**.

1. Для сброса кэша геттера и его выполнения требуется изменить значение используемого в нем свойства компонента. Изменение других свойств компонента кэш геттера не сбрасывает.

1. Сброс кэша геттера также вызывает изменение свойств, обращение к которым находится в вызываемых геттером методах.

1. Свойство начинает управлять очисткой кэша геттера, только после того как при выполнении геттера произошло обращение к этому свойству хотя бы один раз.

1. Все методы компонента имеют общий кэш.

1. Каждый геттер имеет индивидуальный кэш.

1. Изменение значений свойств внутри метода очищает кэш методов.

1. Изменение значений свойств внутри геттера **НЕ** очищает его кэш и не приводит к его повторному выполнению.

1. Изменение состояния одного независимого компонента не влияет на очистку кэша методов другого независимого компонента.

1. Кэш методов становится общим и сбрасывается одновременно для всех компонентов, объединенных в одном компоненте, независимо от метода объединения.

1. Значения вычисляемых выражений, указанных в HTML-шаблоне компонента, кэшируются также как и значения методов компонента.

