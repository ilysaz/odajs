Стандартный блок подсветки кода «**Markdown**» позволяет отображать текст, форматируя его определенным образом, в зависимости от его типа.

Тип форматирования задается в заголовке блока после трех символов грависа (обратных апострофов).

Например,

```text hideGutter
    ```javascript
    let newElement = document.createElement('div');
    newElement.innerHTML = '<input placeholder="Модификатор run">';
    document.body.append(newElement);
    ```
```

В этом примере указан тип «**javascript**», который говорит о том, что текст внутри блока написан на языке «**JavaScript**» и его необходимо подсвечивать определенным способом, специально предусмотренным для данного типа.

```javascript
let newElement = document.createElement('div');
newElement.innerHTML = '<input placeholder="Модификатор run">';
document.body.append(newElement);
```

В нашей системе документации возможности стандартного блока подсветки кода были существенно расширены  специальными модификаторами. К таким модификаторам относятся:

1. Модификатор «**run**». Он позволяет не только подсвечивать код, но и выполнять его.

    Например,

    ```text hideGutter
        ```javascript run
        let newElement = document.createElement('div');
        newElement.innerHTML = '<input placeholder="Модификатор run">';
        document.body.append(newElement);
        ```
    ```

    При его указании под редактором кода появляется дополнительная область, в которой будет выводится результат выполнения этого кода при условии, что он был написан на языке «**JavaScript**». Для этого в заголовке обязательно необходимо указать модификатор «**javascript**».

    ```javascript run
    let newElement = document.createElement('div');
    newElement.innerHTML = '<input placeholder="Модификатор run">';
    document.body.append(newElement);
    ```

    Область вывода представляет собой плавающий фрейм (HTML-элемент «**iframe**»), в котором автоматически формируется стандартный HTML-документ. В заголовок этого документа добавляется тэг «**script**» с типом «**module**», в который записывается код, указанный в редакторе. Этот документ и отображается в окне вывода, выполняя указанный скрипт во вовремя загрузки страницы с этим примером.

1. Модификатор «**edit**» говорит о том, что текст блока можно будет редактировать.

    Он задается следующим образом:

    ```text hideGutter
        ```javascript run_edit
        let newElement = document.createElement('div');
        newElement.innerHTML = ''<input type="number" placeholder="Модификатор edit">;
        document.body.append(newElement);
        ```
    ```

    Если одновременно указать оба модификатора «**run**» и «**edit**», то любое изменение кода в редакторе будет мгновенно приводить к его выполнению.

    Например,

    ```javascript run_edit
    let newElement = document.createElement('div');
    newElement.innerHTML = '<input type="number" placeholder="Модификатор edit">';
    document.body.append(newElement);
    ```

    Если в этом примере изменить тип элемента  «**input**» на «**radio**», то можно убедиться, что сделанные изменения немедленно отобразятся в области вывода.

    ```info hideGutter
    Обратите внимание, что если во время редактирования код будет содержать ошибки, то в окне вывода никакой результат выводится не будет.
    ```

1. Модификатор «**copy**» позволяет отобразить дополнительную кнопку в верхнем правом углу редактора, с помощью которой можно скопировать весь написанный текст без дополнительного его выделения.

    Он задается следующим образом:

    ```text hideGutter
        ```javascript run_copy
            let newElement = document.createElement('div');
            newElement.innerHTML = ''<input type="text" placeholder="Модификатор copy">;
            document.body.append(newElement);
        ```
    ```

    В этом случае не нужно будет выделять весь текст и нажимать сочетание клавиш «Ctrl+C» для того, чтобы  скопировать его. Это будет осуществляться автоматически при нажатии на кнопку «**copy**».

    Например,

    ```javascript run_copy
    let newElement = document.createElement('div');
    newElement.innerHTML = ''<input type="text" placeholder="Модификатор copy">;
    document.body.append(newElement);
    ```

    Чтобы проверить работу кнопки «**copy**», скопированный с ее помощью текст можно вставить в элемент «**input**» этого примера.

1. Модификатор Web-компонента «**[имя-компонента.js]**» говорит о том, что в тело HTML-документа, который используется для вывода результата, будет автоматически добавлен тэг пользовательского компонента с именем, указанным в квадратных скобках без расширения «**.js**».

    Например,

    ```text hideGutter
        ```javascript run_edit_[my-component.js]
        ODA({
            is: 'my-component',
            template: `
                <input type="number" placeholder="Модификатор Web-компонента">
            `
        });
        ```
    ```

    Фактически этот тэг **\<my-component></my-component>** станет хостом одноименного пользовательского компонента. Кроме этого, к заголовку HTML-документа вывода будет автоматически подключена библиотека «oda.js». В результате этого ODA-компонент, записанный в редакторе кода, будет отображаться в окне вывода без каких-либо дополнительных подключений.

    ```javascript run_edit_[my-component.js]
    ODA({
        is: 'my-component',
        template: `
            <input type="text" placeholder="Модификатор Web-компонента">
        `
    });
    ```

    Без модификатора Web-компонента «**[имя-компонента.js]**» тэг пользовательского компонента пришлось бы в теле HTML-документа создавать в ручном режиме. Например, вот так.

    ```javascript run_edit
        ODA({
            is: 'my-component',
            template: `
                <input type="text" placeholder="Модификатор Web-компонента">
            `
        });
        let myComponent = document.createElement('my-component');
        document.body.append(myComponent);
    ```

    ```info hideGutter
    Следует отметить, что библиотека «oda.js» подключается к HTML-документу вывода автоматически только при указании модификатора типа «**javascript**» или при использовании модификатора Web-компонента «**[имя-компонента.js]**». Отдельно подключать ее в этих двух случаях не нужно.
    ```

    Например, если в качестве типа в блоке подсветки кода использовать модификатор «**html**», то все подключения, необходимые для отображения ODA-компонента, придется делать в ручном режиме.

    ```html run_edit
    <!DOCTYPE html>
    <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Welcome to ODA.js</title>
            <script type="module" src="https://cdn.jsdelivr.net/gh/odajs/oda/oda.js"></script>
            <script type="module">
                ODA({
                    is: 'my-component',
                    template: `
                        <span>Привет, ODA-компонент!</span>
                    `
                });
            </script>
        </head>
        <body>
            <my-component></my-component>
        </body>
    </html>
    ```

    Как видно из этого примера, код в этом случае становится намного сложней. Он перенасыщен не важными с точки зрения понимания работы ODA-компонента элементами.

    Кроме этого, скрипт написанные в области редактора автоматически получает имя, указанное в квадратных скобках модификатора компонента. Например, «**my-component.js**». Это имя можно будет использовать потом в других примерах для создания наследников данного компонента.

1. Модификатор родительского компонента «**{имя-родительского-компонента.js}**» говорит о том, что в заголовок HTML-документа, который используется для вывода результата, будет автоматически добавлен скрипт с именем, указанным в фигурных скобках, в котором был объявлен родительский ODA-компонент.

    Например, сначала можно задать родительский компонент, задав имя его скрипта в квадратных скобках.

    Задание родительского компонента.

    ```text
        ```javascript run_edit_[base-component.js]
        ODA({
            is: 'base-component',
            template: `
                <div>Родитель</div>
            `
        });
        ```
    ```

    Этот компонент будет выводится обычным образом.

    ```javascript run_edit_[base-component.js]
    ODA({
        is: 'base-component',
        template: `
            <div>Родитель</div>
        `
    });
    ```

    При задании наследника в фигурных скобках достаточно указать имя предыдущего скрипта, в котором был задан его родитель.

    ```text
        ```javascript _run_edit_[my-component.js]_{base-component.js}
        ODA({
            is: 'my-component',
            extends: 'base-component',
            template: `
                <div>Наследник</div>
            `
        });
        ```
    ```

    В этом случае в коде скрипта наследника не придется повторно задавать код его родителя, усложняя восприятие данного примера.

    ```javascript _run_edit_[my-component.js]_{base-component.js}
        ODA({
            is: 'my-component',
            extends: 'base-component',
            template: `
                <div>Наследник</div>
            `
        });
    ```

    Код родительского компонента будет подключен к заголовку HTML-документа, который используется для вывода наследника, автоматически из того примера, в котором имя родительского скрипта было впервые указано в квадратных скобках.

    Если у компонента нужно указать несколько родителей, то их имена необходимо перечислить в фигурных скобках последовательно друг за другом, отделя одно имя от другого символом подчеркивания.

    Например, объявим первого родителя и зададим имя его скрипта «**base-component-1.js**».

    ```text
        ```javascript run_edit_[base-component-1.js]
        ODA({
            is: 'base-component-1',
            template: `
                <div>Первый родитель</div>
            `
        });
        ```
    ```

    Первый родитель будет выводится обычным образом.

    ```javascript run_edit_[base-component-1.js]
    ODA({
        is: 'base-component-1',
        template: `
            <div>Первый родитель</div>
        `
    });
    ```

    Второго родителя объявим с именем «**base-component-2**».

    ```text
        ```javascript run_edit_[base-component-2.js]
        ODA({
            is: 'base-component-2',
            template: `
                <div>Второй родитель</div>
            `
        });
        ```
    ```

    Имя его скрипта будет отличаться имени самого компонента лишь расширением «**js**».

    ```javascript run_edit_[base-component-2.js]
    ODA({
        is: 'base-component-2',
        template: `
            <div>Родитель 2</div>
        `
    });
    ```

    При объявлении наследника подключим к нему скрипты двух предыдущих компонентов в фигурных скобках.

    ```text
        ```javascript run_edit_[my-component.js]_{base-component-1.js_base-component-2.js}
        ODA({
            is: 'my-component',
            extends: 'base-component-1, base-component-2',
            template: `
                <div>Наследник</div>
            `
        });
        ```
    ```

    В результате этого при отображения наследника будут сначала выводиться все элементы его родителей, хотя код самих родителей в этом примере записан не будет.

    ```javascript run_edit_[my-component.js]_{base-component-1.js_base-component-2.js}
    ODA({
        is: 'my-component',
        extends: 'base-component-1, base-component-2',
        template: `
            <div>Наследник</div>
        `
    });
    ```

    Это существенно упрощает понимание кода наследника, не отягощая его лишней информацией.

1. Модификатор «**h=значение**» позволяет задать фиксированную высоту области вывода результата в пикселях.

    Например,

    ```text
        ```javascript run_edit_[my-component.js]_h=60
        ODA({
            is: 'my-component',
            template: `
                <div>Съешь же ещё этих мягких французских булок да выпей чаю. Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф.</div>
            `
        });
        ```
    ```

    Если высота результата будет превышать предусмотренную высоту окна для его вывода, то с правой стороны появится стандартная полоса прокрутки. С ее помощью можно будет последовательно просмотреть весь полученный результат.

    ```javascript run_edit_[my-component.js]_h=60
    ODA({
        is: 'my-component',
        template: `
            <div>Съешь же ещё этих мягких французских булок да выпей чаю. Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф.</div>
        `
    });
    ```

1. Модификатор «**eh=значение**» позволяет задать фиксированную высоту области редактора кода.

    Значение высоты редактора задается в пикселях, при чем единицы измерения отдельно не указываются. Например,

    ```text
        ```javascript run_edit_[my-component.js]_eh=120
        ODA({
            is: 'my-component',
            template: `
                <div>Съешь же ещё этих мягких французских булок да выпей чаю. Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф.</div>
            `
        });
        ```
    ```

    Если код в редакторе превысит указанную высоту, то с правой стороны окна появится стандартная полоса прокрутки. С помощью можно будет просмотреть последовательно весь кода, написанный в редакторе.

    ```javascript run_edit_[my-component.js]_eh=120
    ODA({
        is: 'my-component',
        template: `
            <div>Съешь же ещё этих мягких французских булок да выпей чаю. Широкая электрификация южных губерний даст мощный толчок подъёму сельского хозяйства. Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф.</div>
        `
    });
    ```

    Данный модификатор следует использовать тогда, когда код примера будет очень большим.

1. Модификатор «**console**» позволяет задать дополнительную кнопку в верхнем правом углу области редактора кода, при нажатии на которую будет выводится области с содержимым консоли данного примера.

    Например,

    ```text
        ```javascript run_edit_[my-component.js]_console
        ODA({
            is: 'my-component',
            template: `
                <div>Чтобы увидеть консоль, нажмите на кнопку в правом верхнем углу редактора.</div>
            `,
            ready()) {
                console.log('Вывод в консоль');
            }
        });
        ```
    ```

    При нажатии на кнопку с изображением списка под редактором кода появится дополнительная область, в которой будут выводится все сообщения, отправляемые в коде данного примера в консоль браузера.

    ```javascript run_edit_[my-component.js]_console
    ODA({
        is: 'my-component',
        template: `
            <div>Чтобы увидеть консоль, нажмите на кнопку в правом верхнем углу редактора.</div>
        `,
        ready() {
            console.log('Вывод в консоль');
        }

    });
    ```

    В области консоли можно выполнить следующие действия:

    1. Очистить содержимое, нажав на кнопку «**clear**».
    1. Перезапустить пример, повторив его выполнение, нажав на кнопку «**refresh**».
    1. Закрыть окно консоли, нажав на кнопку «**close**».

    ```info hideGutter
    Все кнопки управления консоли отображаются в ее верхнем правом углу.
    ```

    Обратите внимание, что все сообщения, отправляемые функцией «**alert**», будут перехватываться и перенаправляться в консоль текущего примера, а не выводится в модальное окно, как это предусмотрено по умолчанию.

    ```javascript run_edit_[my-component.js]_console
    ODA({
        is: 'my-component',
        template: `
            <div>Чтобы увидеть консоль, нажми на кнопку.</div>
        `,
        ready() {
            alert('Это сообщение от alert');
        }
    });
    ```

    Такое изменение в работе функции «**alert**» сделано специально для того, чтобы при загрузке страницы сообщения, передаваемые в ней, не выводились одновременно из всех примеров в отдельных модальных окнах. После полной загрузки страницы все их можно будут спокойно посмотреть в консоли каждого конкретного примера.

    Кроме сообщений стандартного типа «**log**» в консоль можно отравлять сообщения с типом «**warn**» или «**error**»

    ```javascript run_edit_[my-component.js]_console_warn
    ODA({
        is: 'my-component',
        template: `
            <div>Чтобы увидеть консоль, нажмите на кнопку в правом верхнем углу редактора.</div>
        `,
        ready() {
            console.log('Вывод в консоль');
        }

    });
    ```

    ```javascript run_edit_[my-component.js]_console_error
    ODA({
        is: 'my-component',
        template: `
            <div>Чтобы увидеть консоль, нажмите на кнопку в правом верхнем углу редактора.</div>
        `,
        ready() {
            console.log('Вывод в консоль');
        }

    });
    ```