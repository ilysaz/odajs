**$next** — это метод, который позволяет вызвать любую функцию или метод через определенное количество кадров анимации.

Обычно запросы на выполнение кадров анимации в браузерах происходят 60 раз в секунду, но чаще всего это число совпадает с частотой обновления монитора. Из-за этого использование метода **$next** во многих случаях может оказаться эффективнее, чем задание фиксированной временной задержки, например, как это происходит в методе **async**.

В любом компоненте метод **$next** объявлен следующим образом:

```javascript
 $next(handler, takts = 0)
```

Ему передаются 2 параметра:

1. **handler** — вызываемая функция или метод.
1. **tasts** — количество кадров анимации, которое необходимо пропустить до вызова указанного метода или функции.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    onTap() {
        this.$next(() => {this.label='Я выполняюсь через 60 тактов анимации'}, 60);
        this.$next(() => {this.label='Я выполняюсь через 120 тактов анимации'}, 120);
    }
});
```

В данном примере вызываются стрелочные функции через 60 и 120 тактов анимации соответственно. Временная задержка их вызовов будет составлять приблизительно 1 и 2 секунды.

Если с помощью метода **$next** необходимо вызвать не функцию, а метод какого-то компонента, то к нему нужно обязательно привязать контекст этого компонента с помощью метода **bind**.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь только через 60 тактов';
    },
    down() {
        this.label = 'Я выполняюсь только через 120 тактов';
    },
    onTap() {
        this.$next(this.up.bind(this), 60);
        this.$next(this.down.bind(this), 120);
    }
});
```

Если этого не сделать, то указатель **this** внутри вызываемого метода будет иметь неопределенное значение **undefined**.

Например,

```javascript error_run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Указатель this undefined';
    },
    down() {
        this.label = "Ошибка в метода up: Cannot set properties of undefined (setting 'label')";
    },
    onTap() {
        this.$next(this.up, 60);
        this.$next(this.down.bind(this), 120);
    }
});
```

В данном примере произойдет ошибка при обращении к свойству **label**, так как указатель **this** в методе **up**  будет иметь неопределенное значение **undefined**.

Для упрощения вызова методов можно их имя указывать в виде строки.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь только через 60 тактов';
    },
    down() {
        this.label = 'Я выполняюсь только через 120 тактов';
    },
    onTap() {
        this.$next('up', 60);
        this.$next('down', 120);
    }
});
```

В этом случае метод **$next** преобразует переданное ему имя метода в его вызов, присоединив к нему контекст текущего компонента автоматически.

Например, строка **'up'** будет заменена на вызов **this.up.bind(this)**, а строка **'down'** — на вызов **this.down.bind(this)**.

При вызове анонимной функции, контекст которой зависит от способа её вызова, указатель **this** будет ссылаться на глобальный объект **window**.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня',
        count: 0
    },
    onTap() {
        this.$next(function() {this.label="Я создаюсь в объекте window"}, 60);
        this.$next(function() {this.label=window.label}.bind(this), 120);
    }
});
```

В данном примере первая функция вызывается в контексте глобального объекта **windows**, а вторая — в контексте текущего компонента, который был привязан к ней явно с помощью метода **bind**.

Если при вызове метода **$next** указать задержку в ноль тактов, то методы или функции будут вызываться сразу на следующем такте анимации, без какой-либо задержки.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь практически сразу';
    },
    down() {
        this.label = 'Я тоже выполняюсь сразу же';
    },
    onTap() {
        this.$next('up', 0);
        this.$next('down', 0);
    }
});
```

Если второй параметр метода **$next** явно не указан, то он будет иметь нулевой значение по умолчанию.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь практически сразу';
    },
    down() {
        this.label = 'Я тоже выполняюсь сразу же';
    },
    onTap() {
        this.$next('up');
        this.$next('down');
    }
});
```

Данный пример будет работать аналогично предыдущему примеру. Оба метода в нем будут выполняться стразу друг за другом со следующим тактом анимации.
