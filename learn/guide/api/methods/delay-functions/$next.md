**$next** — это метод, который позволяет вызвать любую функцию или метод через определенное количество кадров анимации.

Обычно запросы на выполнение кадров анимации в браузерах происходят 60 раз в секунду, но чаще всего это число совпадает с частотой обновления монитора. Из-за этого использование метода **$next** во многих случаях будет более эффективнее, чем задание фиксированной временной задержки, как это происходит в методе **async**.

Данный метод объявлен следующим образом:

```javascript
 $next(handler, takts = 0)
```

Ему передаются 2 параметра:

1. **handler** — вызываемая функция или метод.
1. **tasts** — количество кадров анимации, которое необходимо пропустить до вызова указанного метода.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    onTap() {
        this.$next(() => {this.label='Я выполняюсь через 60 тактов анимации'}, 60);
        this.$next(() => {this.label='Я выполняюсь через 120 тактов анимации'}, 120);
    }
});
```

В данном примере вызываются стрелочные функции через 60 и 120 тактов анимации соответственно. Временная задержка их вызовов будет составлять приблизительно 1 и 2 секунды.

Если с помощью метода **$next** необходимо вызвать не функцию, а метод какого-то компонента, то к нему нужно обязательно привязать контекст этого компонента с помощью метода **bind**.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь только через 60 тактов';
    },
    down() {
        this.label = 'Я выполняюсь только через 120 тактов';
    },
    onTap() {
        this.$next(this.up.bind(this), 60);
        this.$next(this.down.bind(this), 120);
    }
});
```

Если этого не сделать, то указатель **this** внутри вызываемого метода будет ссылаться уже не на сам компонент, а на глобальный объект **window**.

Например,

```javascript error_run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я создаюсь в объекте window';
    },
    down() {
        this.label = window.label;
    },
    onTap() {
        this.$next(this.up, 60);
        this.$next(this.down.bind(this), 120);
    }
});
```

В данном примере метод **up** присвоит значение не свойству **label** данного компонента, а создаст одноименное свойтсво у глобального объекта **window**. Вызов метода down с прикрепленным контекстом подтвердит это через 120 тактов анимации.

Аналогичная ситуация происходит при вызове анонимной функции, контекст которой зависит от способа её вызова. Метод **$next** вызывает её с помощью метода **setTimeout**, внутри которого указатель **this** всегда ссылаться на глобальный объект **window**.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня',
        count: 0
    },
    onTap() {
        this.async(function() {this.label="Я создаюсь в объекте window"}, 60);
        this.async(function() {this.label=window.label}.bind(this), 120);
    }
});
```

Если при вызове метода **$next** указать задержку в ноль тактов, то указанные методы или функции будут вызваны сразу на следующем такте анимации, без какой-либо задержки.

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь практически сразу';
    },
    down() {
        this.label = 'Я тоже выполняюсь сразу же';
    },
    onTap() {
        this.$next(this.up.bind(this));
        this.$next(this.down.bind(this));
    }
});
```
