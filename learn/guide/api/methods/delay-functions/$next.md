**$next** — это метод, который позволяет вызвать любую функцию или метод через определенное количество кадров анимации.

Обычно запросы на выполнение кадров анимации в браузерах происходят 60 раз в секунду, но чаще всего это число совпадает с частотой обновления монитора. Из-за этого использование метода **$next** во многих случаях может оказаться эффективнее, чем задание фиксированной временной задержки, например, как это происходит в методе **async**.

В любом компоненте метод **$next** объявлен следующим образом:

```javascript
 $next(handler, takts = 0)
```

Ему передаются 2 параметра:

1. **handler** — вызываемая функция или метод.
1. **tasts** — количество кадров анимации, которое необходимо пропустить до вызова указанного метода или функции.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    onTap() {
        this.$next(() => {this.label='Я выполняюсь через 60 тактов анимации'}, 60);
        this.$next(() => {this.label='Я выполняюсь через 120 тактов анимации'}, 120);
    }
});
```

В данном примере вызываются стрелочные функции через 60 и 120 тактов анимации соответственно. Временная задержка их вызовов будет составлять приблизительно 1 и 2 секунды.

Если с помощью метода **$next** необходимо вызвать не функцию, а метод какого-то компонента, то к нему обязательно нужно будет привязать контекст этого компонента с помощью метода **bind**.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь только через 60 тактов';
    },
    down() {
        this.label = 'Я выполняюсь только через 120 тактов';
    },
    onTap() {
        this.$next(this.up.bind(this), 60);
        this.$next(this.down.bind(this), 120);
    }
});
```

Если этого не сделать, то указатель **this** внутри вызываемого метода будет иметь неопределенное значение **undefined**.

Например,

```javascript error_run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Указатель this undefined';
    },
    down() {
        this.label = "Ошибка в методе up: Cannot set properties of undefined (setting 'label')";
    },
    onTap() {
        this.$next(this.up, 60);
        this.$next(this.down.bind(this), 120);
    }
});
```

В данном примере произойдет ошибка при обращении к свойству **label** метода **up**, так как указатель **this** внутри него будет иметь неопределенное значение **undefined**.

Для того, чтобы явно не привязывать контекст компонента к методу, имена методов можно указывать просто в виде строки.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь только через 60 тактов';
    },
    down() {
        this.label = 'Я выполняюсь только через 120 тактов';
    },
    onTap() {
        this.$next('up', 60);
        this.$next('down', 120);
    }
});
```

В этом случае метод **$next** преобразует переданное ему имя метода в его вызов, присоединив к нему контекст текущего компонента автоматически.

Например, строка **'up'** будет заменена на вызов **this.up.bind(this)**, а строка **'down'** — на вызов **this.down.bind(this)**.

При вызове анонимной функции, контекст которой зависит от способа её вызова, указатель **this** в строгом режиме будет так же не определен, т.е. будет иметь значение **undefined**.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня',
        count: 0
    },
    onTap() {
        this.$next(function() {this.label="Указатель this undefined"}, 60);
        this.$next(function() {this.label="Ошибка: Cannot set properties of undefined (setting 'label')"}.bind(this), 120);
    }
});
```

Из-за этого при вызове первой функции возникнет ошибка обращения к объекту **undefined**. У второй функции контекст компонента будет привязан в ручном режиме с помощью метода **bind** и никакая ошибка возникать в этом случае не будет.

Если при вызове метода **$next** задать задержку в ноль тактов, то указанные методы или функции будут вызываться сразу на следующем такте анимации.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь практически сразу';
    },
    down() {
        this.label = 'Я тоже выполняюсь сразу же';
    },
    onTap() {
        this.$next('up', 0);
        this.$next('down', 0);
    }
});
```

Если у метода **$next** не указать второй параметр, то его значение будет задано по умолчанию равным нулю тактам.

Например,

```javascript _run_edit_[my-component.js]
 ODA({
    is: 'my-component',
    template: `
        <button @tap="onTap">{{label}}</button>
    `,
    props: {
        label: 'Нажмите меня'
    },
    up() {
        this.label = 'Я выполняюсь практически сразу';
    },
    down() {
        this.label = 'Я тоже выполняюсь сразу же';
    },
    onTap() {
        this.$next('up');
        this.$next('down');
    }
});
```

В результате этого данный пример будет работать абсолютно аналогично предыдущему, т.е. оба метода будут выполняться последовательно друг за другом сразу на следующем такте анимации.
